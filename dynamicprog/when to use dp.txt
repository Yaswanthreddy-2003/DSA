ğŸ” When to Consider DP
1. Recursion + Overlapping Subproblems
If you're writing recursion and same inputs are getting recomputed, thatâ€™s a DP candidate.

E.g., f(n) = f(n-1) + f(n-2) â†’ classic Fibonacci

ğŸ“Š Problem Types That Usually Require DP
âœ… Count the number of ways
Example: Climbing stairs, coin change (total ways), maze paths

Hint: Use DP[i] = total ways to reach i

âœ… Find the min/max value
Example: Frog jump with min energy, max sum subarray, knapsack

Hint: Think of DP[i] = best value for i

âœ… Subset/Partition problems
Example: Subset sum, equal partition, target sum

If a subset is involved, DP is your friend.

âœ… String problems
Example: LCS, Edit distance, Palindrome partition

90% of string comparison/modification problems use 2D DP.

âœ… Games / Turn based
Example: Nim game, stone game

Use DP with memoization to store winning/losing states.

âœ… DP on Trees / Graphs
When tree-based recursion is repeated, DP on trees works.

E.g., Diameter of tree, Tree DP (max sum from subtree)

ğŸš© Red Flags That Hint DP
"Find the total number of ___"

"Maximize/Minimize ___"

"Return true/false if ___ is possible"

Recursion with repeated calls on same inputs

Input size is too big for brute force, like 10âµ elements with exponential choices

ğŸ§  Shortcut Thinking
If problem says...	Think...
â€œMin/Max of...â€	DP with value updates
â€œTotal number of ways...â€	DP with counting
â€œCan you reach/achieve something?â€	DP with boolean values
â€œChoose or not choose itemsâ€	0/1 Knapsack-style DP
â€œBreak string into partsâ€	DP with partitioning
â€œCompare two sequencesâ€	2D DP
â€œRecursive tree with repeated callsâ€	Tree DP

main steps to convert the problem.
1.convert the problem into indexing
2.do all stuffs on that index.
3.take the min (all stuffs).